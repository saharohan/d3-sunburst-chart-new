{"ast":null,"code":"import { select, event } from 'd3-selection';\nimport { scaleLinear, scaleSqrt } from 'd3-scale';\nimport { hierarchy, partition } from 'd3-hierarchy';\nimport { arc } from 'd3-shape';\nimport { path } from 'd3-path';\nimport { interpolate } from 'd3-interpolate';\nimport { transition } from 'd3-transition';\nimport Kapsule from 'kapsule';\nimport accessorFn from 'accessor-fn';\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \".sunburst-viz .slice path {\\n  cursor: pointer;\\n}\\n\\n.sunburst-viz text {\\n  font-family: Sans-serif;\\n  font-size: 12px;\\n  dominant-baseline: middle;\\n  text-anchor: middle;\\n  pointer-events: none;\\n  fill: #222;\\n}\\n\\n.sunburst-viz text .text-contour {\\n  fill: none;\\n  stroke: white;\\n  stroke-width: 5;\\n  stroke-linejoin: 'round';\\n}\\n\\n.sunburst-viz .main-arc {\\n  stroke: white;\\n  stroke-width: 1px;\\n  transition: opacity .4s;\\n}\\n\\n.sunburst-viz .main-arc:hover {\\n  opacity: 0.85;\\n  transition: opacity .05s;\\n}\\n\\n.sunburst-viz .hidden-arc {\\n  fill: none;\\n}\\n\\n.sunburst-tooltip {\\n  display: none;\\n  position: absolute;\\n  max-width: 320px;\\n  margin-top: 20px;\\n  margin-left: 8px;\\n  padding: 5px;\\n  border-radius: 3px;\\n  font: 12px sans-serif;\\n  color: #eee;\\n  background: rgba(0,0,0,0.65);\\n  pointer-events: none;\\n}\\n\\n.sunburst-tooltip .tooltip-title {\\n  font-weight: bold;\\n  text-align: center;\\n}\\n\";\nstyleInject(css);\nvar TRANSITION_DURATION = 750;\nvar CHAR_PX = 6;\nvar sunburst = Kapsule({\n  props: {\n    width: {\n      default: window.innerWidth\n    },\n    height: {\n      default: window.innerHeight\n    },\n    data: {\n      onChange: function onChange() {\n        this._parseData();\n      }\n    },\n    children: {\n      default: 'children',\n      onChange: function onChange() {\n        this._parseData();\n      }\n    },\n    sort: {\n      onChange: function onChange() {\n        this._parseData();\n      }\n    },\n    label: {\n      default: function _default(d) {\n        return d.name;\n      }\n    },\n    size: {\n      default: 'value',\n      onChange: function onChange() {\n        this._parseData();\n      }\n    },\n    color: {\n      default: function _default(d) {\n        return 'lightgrey';\n      }\n    },\n    minSliceAngle: {\n      default: .2\n    },\n    showLabels: {\n      default: true\n    },\n    tooltipContent: {\n      default: function _default(d) {\n        return '';\n      },\n      triggerUpdate: false\n    },\n    focusOnNode: {\n      onChange: function onChange(d, state) {\n        if (d && state.initialised) {\n          moveStackToFront(d.__dataNode);\n        }\n\n        function moveStackToFront(elD) {\n          state.svg.selectAll('.slice').filter(function (d) {\n            return d === elD;\n          }).each(function (d) {\n            this.parentNode.appendChild(this);\n\n            if (d.parent) {\n              moveStackToFront(d.parent);\n            }\n          });\n        }\n      }\n    },\n    onNodeClick: {\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    _parseData: function _parseData(state) {\n      if (state.data) {\n        var hierData = hierarchy(state.data, accessorFn(state.children)).sum(accessorFn(state.size));\n\n        if (state.sort) {\n          hierData.sort(state.sort);\n        }\n\n        partition().padding(0)(hierData);\n        hierData.descendants().forEach(function (d, i) {\n          d.id = i; // Mark each node with a unique ID\n\n          d.data.__dataNode = d; // Dual-link data nodes\n        });\n        state.layoutData = hierData.descendants();\n      }\n    }\n  },\n  init: function init(domNode, state) {\n    var _this = this;\n\n    state.chartId = Math.round(Math.random() * 1e12); // Unique ID for DOM elems\n\n    state.radiusScale = scaleSqrt();\n    state.angleScale = scaleLinear().domain([0, 10]) // For initial build-in animation\n    .range([0, 2 * Math.PI]).clamp(true);\n    state.arc = arc().startAngle(function (d) {\n      return state.angleScale(d.x0);\n    }).endAngle(function (d) {\n      return state.angleScale(d.x1);\n    }).innerRadius(function (d) {\n      return Math.max(0, state.radiusScale(d.y0));\n    }).outerRadius(function (d) {\n      return Math.max(0, state.radiusScale(d.y1));\n    });\n    var el = select(domNode).append('div').attr('class', 'sunburst-viz');\n    state.svg = el.append('svg');\n    state.canvas = state.svg.append('g'); // tooltips\n\n    state.tooltip = select('body').append('div').attr('class', 'sunburst-tooltip'); // tooltip cleanup on unmount\n\n    domNode.addEventListener('DOMNodeRemoved', function (e) {\n      if (e.target === this) {\n        state.tooltip.remove();\n      }\n    });\n    state.canvas.on('mousemove', function () {\n      state.tooltip.style('left', event.pageX + 'px').style('top', event.pageY + 'px');\n    }); // Reset focus by clicking on canvas\n\n    state.svg.on('click', function () {\n      return _this.focusOnNode(null);\n    });\n  },\n  update: function update(state) {\n    var _this2 = this;\n\n    var maxRadius = Math.min(state.width, state.height) / 2;\n    state.radiusScale.range([maxRadius * .1, maxRadius]);\n    state.svg.style('width', state.width + 'px').style('height', state.height + 'px').attr('viewBox', -state.width / 2 + ' ' + -state.height / 2 + ' ' + state.width + ' ' + state.height);\n    if (!state.layoutData) return;\n    var focusD = state.focusOnNode && state.focusOnNode.__dataNode || {\n      x0: 0,\n      x1: 1,\n      y0: 0,\n      y1: 1\n    };\n    var slice = state.canvas.selectAll('.slice').data(state.layoutData.filter(function (d) {\n      return (// Show only slices with a large enough angle\n        d.x1 >= focusD.x0 && d.x0 <= focusD.x1 && (d.x1 - d.x0) / (focusD.x1 - focusD.x0) > state.minSliceAngle / 360\n      );\n    }), function (d) {\n      return d.id;\n    });\n    var nameOf = accessorFn(state.label);\n    var colorOf = accessorFn(state.color);\n    var transition$$1 = transition().duration(TRANSITION_DURATION); // Apply zoom\n\n    state.svg.transition(transition$$1).tween('scale', function () {\n      var xd = interpolate(state.angleScale.domain(), [focusD.x0, focusD.x1]);\n      var yd = interpolate(state.radiusScale.domain(), [focusD.y0, 1]);\n      return function (t) {\n        state.angleScale.domain(xd(t));\n        state.radiusScale.domain(yd(t));\n      };\n    }); // Exiting\n\n    var oldSlice = slice.exit().transition(transition$$1).style('opacity', 0).remove();\n    oldSlice.select('path.main-arc').attrTween('d', function (d) {\n      return function () {\n        return state.arc(d);\n      };\n    });\n    oldSlice.select('path.hidden-arc').attrTween('d', function (d) {\n      return function () {\n        return middleArcLine(d);\n      };\n    }); // Entering\n\n    var newSlice = slice.enter().append('g').attr('class', 'slice').style('opacity', 0).on('click', function (d) {\n      event.stopPropagation();\n\n      (state.onNodeClick || _this2.focusOnNode)(d.data);\n    }).on('mouseover', function (d) {\n      state.tooltip.style('display', 'inline');\n      state.tooltip.html('<div class=\"tooltip-title\">' + getNodeStack(d).map(function (d) {\n        return nameOf(d.data);\n      }).join(' > ') + '</div>' + state.tooltipContent(d.data, d));\n    }).on('mouseout', function () {\n      state.tooltip.style('display', 'none');\n    });\n    newSlice.append('path').attr('class', 'main-arc').style('fill', function (d) {\n      return colorOf(d.data, d.parent);\n    });\n    newSlice.append('path').attr('class', 'hidden-arc').attr('id', function (d) {\n      return 'hidden-arc-' + state.chartId + '-' + d.id;\n    });\n    var label = newSlice.append('text').attr('class', 'path-label'); // Add white contour\n\n    label.append('textPath').attr('class', 'text-contour').attr('startOffset', '50%').attr('xlink:href', function (d) {\n      return '#hidden-arc-' + state.chartId + '-' + d.id;\n    });\n    label.append('textPath').attr('class', 'text-stroke').attr('startOffset', '50%').attr('xlink:href', function (d) {\n      return '#hidden-arc-' + state.chartId + '-' + d.id;\n    }); // Entering + Updating\n\n    var allSlices = slice.merge(newSlice);\n    allSlices.style('opacity', 1);\n    allSlices.select('path.main-arc').transition(transition$$1).attrTween('d', function (d) {\n      return function () {\n        return state.arc(d);\n      };\n    }).style('fill', function (d) {\n      return colorOf(d.data, d.parent);\n    });\n    allSlices.select('path.hidden-arc').transition(transition$$1).attrTween('d', function (d) {\n      return function () {\n        return middleArcLine(d);\n      };\n    });\n    allSlices.select('.path-label').transition(transition$$1).styleTween('display', function (d) {\n      return function () {\n        return state.showLabels && textFits(d) ? null : 'none';\n      };\n    }); // Ensure propagation of data to children\n\n    allSlices.selectAll('text.path-label').select('textPath.text-contour');\n    allSlices.selectAll('text.path-label').select('textPath.text-stroke');\n    allSlices.selectAll('text.path-label').selectAll('textPath').text(function (d) {\n      return nameOf(d.data);\n    }); //\n\n    function middleArcLine(d) {\n      var halfPi = Math.PI / 2;\n      var angles = [state.angleScale(d.x0) - halfPi, state.angleScale(d.x1) - halfPi];\n      var r = Math.max(0, (state.radiusScale(d.y0) + state.radiusScale(d.y1)) / 2);\n      if (!r || !(angles[1] - angles[0])) return '';\n      var middleAngle = (angles[1] + angles[0]) / 2;\n      var invertDirection = middleAngle > 0 && middleAngle < Math.PI; // On lower quadrants write text ccw\n\n      if (invertDirection) {\n        angles.reverse();\n      }\n\n      var path$$1 = path();\n      path$$1.arc(0, 0, r, angles[0], angles[1], invertDirection);\n      return path$$1.toString();\n    }\n\n    function textFits(d) {\n      var deltaAngle = state.angleScale(d.x1) - state.angleScale(d.x0);\n      var r = Math.max(0, (state.radiusScale(d.y0) + state.radiusScale(d.y1)) / 2);\n      var perimeter = r * deltaAngle;\n      return nameOf(d.data).toString().length * CHAR_PX < perimeter;\n    }\n\n    function getNodeStack(d) {\n      var stack = [];\n      var curNode = d;\n\n      while (curNode) {\n        stack.unshift(curNode);\n        curNode = curNode.parent;\n      }\n\n      return stack;\n    }\n  }\n});\nexport default sunburst;","map":null,"metadata":{},"sourceType":"module"}